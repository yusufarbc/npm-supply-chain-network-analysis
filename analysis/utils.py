import os
import pandas as pd

def export_results(risk_df, G, output_dir='results'):
    # Ensure results directory exists
    os.makedirs(output_dir, exist_ok=True)

    print("Exporting results...")

    # 1. Full Analysis Table
    risk_df.to_csv(f'{output_dir}/risk_scores.csv', index=False)
    print(f" - Saved {output_dir}/risk_scores.csv")

    # 2. Gephi Nodes
    # Create numeric ID map for Gephi (safer than string IDs)
    # Sort by rank/risk for consistent IDs
    sorted_nodes = risk_df.sort_values('risk_score', ascending=False)['package'].tolist()
    id_map = {pkg: i+1 for i, pkg in enumerate(sorted_nodes)}
    
    # Prepare Gephi DataFrame
    gephi_nodes = risk_df.copy()
    gephi_nodes['Id'] = gephi_nodes['package'].map(id_map)
    gephi_nodes['Label'] = gephi_nodes['package']
    
    # Rename columns to Gephi standard (CamelCase often preferred)
    col_mapping = {
        'risk_score': 'RiskScore',
        'in_degree': 'InDegree',
        'out_degree': 'OutDegree',
        'betweenness': 'Betweenness',
        'dependents_count': 'DependentsCount',
        'downloads': 'Downloads',
        'rank': 'Rank',
        'type': 'Type'
    }
    gephi_nodes = gephi_nodes.rename(columns=col_mapping)
    
    # Select columns that exist
    cols_to_export = ['Id', 'Label'] + [c for c in col_mapping.values() if c in gephi_nodes.columns]
    gephi_nodes = gephi_nodes[cols_to_export]
    
    gephi_nodes.to_csv(f'{output_dir}/gephi_nodes.csv', index=False)
    print(f" - Saved {output_dir}/gephi_nodes.csv")

    # 3. Gephi Edges
    # Columns: Source, Target, Type
    gephi_edges = pd.DataFrame(list(G.edges()), columns=['Source', 'Target'])
    
    # Map Source and Target to numeric IDs
    gephi_edges['Source'] = gephi_edges['Source'].map(id_map)
    gephi_edges['Target'] = gephi_edges['Target'].map(id_map)
    
    # Filter out edges where nodes might be missing (shouldn't happen but safe)
    gephi_edges = gephi_edges.dropna()
    gephi_edges['Source'] = gephi_edges['Source'].astype(int)
    gephi_edges['Target'] = gephi_edges['Target'].astype(int)
    
    gephi_edges['Type'] = 'Directed'
    gephi_edges.to_csv(f'{output_dir}/gephi_edges.csv', index=False)
    print(f" - Saved {output_dir}/gephi_edges.csv")

    # 4. Generate README.md Report
    generate_results_readme(risk_df, output_dir)

def generate_results_readme(risk_df, output_dir):
    readme_path = f'{output_dir}/README.md'
    
    with open(readme_path, 'w', encoding='utf-8') as f:
        f.write("# Analysis Results\n\n")
        f.write("Automated analysis report generated by the pipeline.\n\n")
        
        # Top 20 Risk Score
        f.write("## ðŸš¨ Top 20 Critical Packages (Risk Score)\n")
        f.write("Packages with the highest Composite Risk Score (BRS).\n\n")
        top_risk = risk_df.sort_values('risk_score', ascending=False).head(20)
        # Manual markdown table generation to avoid tabulate dependency if not present
        f.write("| Package | Risk Score | In-Degree | Betweenness |\n")
        f.write("| :--- | :--- | :--- | :--- |\n")
        for _, row in top_risk.iterrows():
            f.write(f"| {row['package']} | {row['risk_score']:.4f} | {row['in_degree']:.4f} | {row['betweenness']:.4f} |\n")
        f.write("\n")
        
        # Top 20 In-Degree
        f.write("## ðŸ”— Top 20 Most Depended-upon Packages (In-Degree)\n")
        f.write("Packages that have the most direct dependents in this network.\n\n")
        top_in = risk_df.sort_values('in_degree', ascending=False).head(20)
        f.write("| Package | In-Degree | Out-Degree | Risk Score |\n")
        f.write("| :--- | :--- | :--- | :--- |\n")
        for _, row in top_in.iterrows():
            f.write(f"| {row['package']} | {row['in_degree']:.4f} | {row['out_degree']:.4f} | {row['risk_score']:.4f} |\n")
        f.write("\n")
        
        # Top 20 Betweenness
        f.write("## ðŸŒ‰ Top 20 Bridges (Betweenness Centrality)\n")
        f.write("Packages that act as bridges between different parts of the ecosystem.\n\n")
        top_btw = risk_df.sort_values('betweenness', ascending=False).head(20)
        f.write("| Package | Betweenness | In-Degree | Risk Score |\n")
        f.write("| :--- | :--- | :--- | :--- |\n")
        for _, row in top_btw.iterrows():
            f.write(f"| {row['package']} | {row['betweenness']:.4f} | {row['in_degree']:.4f} | {row['risk_score']:.4f} |\n")
        f.write("\n")
        
    print(f" - Saved {readme_path}")
